class HierarchicalEntropyModel(nn.Module):
    def __init__(self):
        super().__init__()
        # Context를 받아서 4개의 파라미터 예측
        # 1. p_nonzero (0이 아닐 확률)
        # 2. p_pos (양수일 확률)
        # 3. mu_log (log(|y|)의 평균)
        # 4. sigma_log (log(|y|)의 표준편차)
        self.net = nn.Sequential(..., nn.Linear(ctx_dim, 4))

    def forward(self, y_true, context):
        # y_true: 실제 양자화된 DCT 계수 (예: -500, 0, 3, ...)
        
        # 네트워크 출력 예측
        preds = self.net(context)
        p_nonzero = torch.sigmoid(preds[:, 0])
        p_pos = torch.sigmoid(preds[:, 1])
        mu_log = preds[:, 2]
        sigma_log = F.softplus(preds[:, 3]) + 1e-6

        # --- 확률 계산 (비트 계산) ---
        
        # 1. Zero/Non-zero 확률
        is_zero = (torch.abs(y_true) < 0.5).float()
        # 0일 때 확률: (1 - p_nonzero)
        # 0 아닐 때 확률: p_nonzero
        prob_step1 = is_zero * (1 - p_nonzero) + (1 - is_zero) * p_nonzero

        # 2. Sign 확률 (0이 아닐 때만 적용)
        is_pos = (y_true > 0).float()
        prob_step2 = is_pos * p_pos + (1 - is_pos) * (1 - p_pos)
        # 0일 때는 부호 확률이 필요 없으므로 1로 처리 (log(1)=0 비트 소모 없음)
        prob_step2 = is_zero * 1.0 + (1 - is_zero) * prob_step2

        # 3. Magnitude 확률 (로그 스케일 분포)
        # y가 0이 아닐 때, |y|가 나올 확률
        # 우리는 log(|y|)가 가우시안을 따른다고 가정 (Log-Normal 분포 유사)
        abs_y = torch.abs(y_true)
        
        # 적분 구간: log(|y| - 0.5) ~ log(|y| + 0.5)
        # 큰 값일수록 구간이 로그 스케일이라 좁아지지만, 분포도 같이 넓어짐
        # 0인 경우 계산 에러 방지를 위해 clamp
        safe_abs = torch.clamp(abs_y, min=0.5) 
        
        dist = torch.distributions.Normal(mu_log, sigma_log)
        cdf_upper = dist.cdf(torch.log(safe_abs + 0.5))
        cdf_lower = dist.cdf(torch.log(safe_abs - 0.5))
        
        prob_magnitude = cdf_upper - cdf_lower
        
        # 마찬가지로 0일 때는 크기 확률 필요 없음
        prob_step3 = is_zero * 1.0 + (1 - is_zero) * prob_magnitude

        # 4. 최종 확률 결합
        total_prob = prob_step1 * prob_step2 * prob_step3
        
        # 비트 폭발 방지 (Clamp)
        total_prob = torch.clamp(total_prob, min=1e-9)
        
        return total_prob
